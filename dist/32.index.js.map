{"version":3,"file":"32.index.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACjEA;AACA;AACA;AACA;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./utils/docker.ts","webpack:///./utils/docker/cosign.ts","webpack:///./commands/docker/builder.ts","webpack:///./util.ts","webpack:///./utils/datasource/index.ts","webpack:///./utils/versioning/ubuntu.ts","webpack:///./utils/versioning/index.ts","webpack:///./utils/renovate.ts","webpack:///./utils/builds.ts","webpack:///./utils/config.ts","webpack:///./utils/docker/buildx.ts","webpack:///./utils/docker/common.ts","webpack:///./utils/types.ts"],"sourcesContent":["import { setTimeout } from 'node:timers/promises';\nimport { dockerBuildx } from './docker/common';\nimport log from './logger';\nimport { ExecError } from './types';\nimport is from '@sindresorhus/is';\nimport * as chalk from 'chalk';\nconst errors = [\n    'unexpected status: 400 Bad Request',\n    ': no response',\n    'error writing layer blob',\n];\nfunction canRetry(err) {\n    return errors.some((str) => err.stderr.includes(str));\n}\nexport async function build({ image, imagePrefix, cache, cacheFromTags, cacheToTags, tag = 'latest', tags, dryRun, buildArgs, platforms, push, }) {\n    const args = ['build', `--tag=${imagePrefix}/${image}:${tag}`];\n    if (tags?.length) {\n        args.push(...tags.map((tag) => `--tag=${imagePrefix}/${image}:${tag}`));\n    }\n    if (is.nonEmptyArray(buildArgs)) {\n        args.push(...buildArgs.map((b) => `--build-arg=${b}`));\n    }\n    if (is.string(cache)) {\n        const cachePrefix = cache.split('/')[0]?.match(/[.:]/)\n            ? ''\n            : `${imagePrefix}/`;\n        const cacheImage = `${cachePrefix}${cache}:${image.replace(/\\//g, '-')}`;\n        args.push(`--cache-from=${cacheImage}-${tag}`);\n        if (is.nonEmptyArray(cacheFromTags)) {\n            for (const ctag of cacheFromTags) {\n                args.push(`--cache-from=${cacheImage}-${ctag}`);\n            }\n        }\n        if (!dryRun && push) {\n            args.push(`--cache-to=type=registry,ref=${cacheImage}-${tag},mode=max,ignore-error=true`);\n            if (is.nonEmptyArray(cacheToTags)) {\n                for (const ctag of cacheToTags) {\n                    args.push(`--cache-to=type=registry,ref=${cacheImage}-${ctag},mode=max,ignore-error=true`);\n                }\n            }\n        }\n    }\n    if (platforms?.length) {\n        args.push(`--platform=${platforms.join(',')}`);\n    }\n    if (dryRun) {\n        log.warn(chalk.yellow('[DRY_RUN]'), chalk.blue('Would push'));\n    }\n    else if (push) {\n        args.push('--push', '--provenance=false');\n    }\n    for (let build = 0;; build++) {\n        try {\n            await dockerBuildx(...args, '.');\n            break;\n        }\n        catch (e) {\n            if (e instanceof ExecError && canRetry(e) && build < 2) {\n                log.error(chalk.red(`docker build error on try ${build}`), e);\n                await setTimeout(5000);\n                continue;\n            }\n            throw e;\n        }\n    }\n}\n","import { exec } from '../../util';\nexport async function cosign(...args) {\n    return await exec('cosign', [...args]);\n}\n","import { exec, exists, getArg, isDryRun, readJson } from '../../util';\nimport { addHostRule, getBuildList } from '../../utils/builds';\nimport { readDockerConfig } from '../../utils/config';\nimport { build } from '../../utils/docker';\nimport { init } from '../../utils/docker/buildx';\nimport { dockerDf, dockerPrune } from '../../utils/docker/common';\nimport { cosign } from '../../utils/docker/cosign';\nimport log from '../../utils/logger';\nimport { getInput, setFailed } from '@actions/core';\nimport is from '@sindresorhus/is';\nimport * as chalk from 'chalk';\nimport { getDefaultVersioning } from 'renovate/dist/modules/datasource';\nimport { get as getVersioning } from 'renovate/dist/modules/versioning';\nfunction createTag(tagSuffix, version) {\n    return is.nonEmptyString(tagSuffix) && tagSuffix !== 'latest'\n        ? `${version}-${tagSuffix}`\n        : version;\n}\nasync function buildAndPush({ imagePrefix, image, buildArg, buildArgs, buildOnly, cache, dryRun, tagSuffix, versioning, majorMinor, prune, platforms, skipLatestTag, }, tobuild) {\n    const builds = [];\n    const failed = [];\n    const ver = getVersioning(versioning);\n    const versionsMap = new Map();\n    const dfExists = await exists('df');\n    if (majorMinor) {\n        for (const version of tobuild.versions) {\n            const minor = ver.getMinor(version);\n            const major = ver.getMajor(version);\n            const isStable = ver.isStable(version);\n            if (isStable && is.number(major) && `${major}` !== version) {\n                versionsMap.set(`${major}`, version);\n            }\n            if (isStable &&\n                is.number(major) &&\n                is.number(minor) &&\n                `${major}.${minor}` !== version) {\n                versionsMap.set(`${major}.${minor}`, version);\n            }\n        }\n    }\n    // istanbul ignore if: only linux\n    if (dfExists) {\n        await exec('df', ['-h']);\n    }\n    let shouldSign = false;\n    if (!dryRun && !buildOnly) {\n        shouldSign = await exists('cosign');\n        if (!shouldSign) {\n            log.warn('Cosign is not installed. Skipping container signing');\n        }\n    }\n    for (const version of tobuild.versions) {\n        const tag = createTag(tagSuffix, version.replace(/\\+.+/, ''));\n        const imageVersion = `${imagePrefix}/${image}:${tag}`;\n        log(`Building ${imageVersion}`);\n        try {\n            const minor = ver.getMinor(version);\n            const major = ver.getMajor(version);\n            const cacheFromTags = [tagSuffix ?? 'latest'];\n            const cacheToTags = [];\n            const tags = [];\n            if (is.number(major)) {\n                const nTag = createTag(tagSuffix, `${major}`);\n                cacheFromTags.push(nTag);\n                if (versionsMap.get(`${major}`) === version) {\n                    cacheToTags.push(nTag);\n                    if (majorMinor) {\n                        tags.push(nTag);\n                    }\n                }\n            }\n            if (is.number(major) && is.number(minor)) {\n                const nTag = createTag(tagSuffix, `${major}.${minor}`);\n                cacheFromTags.push(nTag);\n                if (versionsMap.get(`${major}.${minor}`) === version) {\n                    cacheToTags.push(nTag);\n                    if (majorMinor) {\n                        tags.push(nTag);\n                    }\n                }\n            }\n            if (version === tobuild.latestStable && skipLatestTag !== true) {\n                cacheToTags.push(tagSuffix ?? 'latest');\n                tags.push(tagSuffix ?? 'latest');\n            }\n            await build({\n                image,\n                imagePrefix,\n                tag,\n                tags,\n                cache,\n                cacheFromTags,\n                cacheToTags,\n                buildArgs: [...(buildArgs ?? []), `${buildArg}=${version}`],\n                dryRun,\n                platforms,\n                push: !buildOnly,\n            });\n            if (!buildOnly && shouldSign) {\n                log('Signing image', imageVersion);\n                await cosign('sign', '--yes', imageVersion);\n                for (const imageVersion of tags.map((tag) => `${imagePrefix}/${image}:${tag}`)) {\n                    log('Signing image', imageVersion);\n                    await cosign('sign', '--yes', imageVersion);\n                }\n            }\n            log(`Build ${imageVersion}`);\n            builds.push(version);\n        }\n        catch (err) {\n            log.error(err);\n            failed.push(version);\n        }\n        await dockerDf();\n        // istanbul ignore if: only linux\n        if (dfExists) {\n            await exec('df', ['-h']);\n        }\n        if (prune) {\n            await dockerPrune();\n            // istanbul ignore if: only linux\n            if (dfExists) {\n                await exec('df', ['-h']);\n            }\n        }\n    }\n    if (builds.length) {\n        log('Build list:' + builds.join(' '));\n    }\n    if (failed.length) {\n        log.warn('Failed list:' + failed.join(' '));\n        throw new Error('failed');\n    }\n}\nasync function generateImages(config) {\n    const buildList = await getBuildList(config);\n    if (!buildList?.versions.length) {\n        setFailed(`No versions found.`);\n        return;\n    }\n    await buildAndPush(config, buildList);\n}\nexport async function run() {\n    const dryRun = isDryRun();\n    const configFile = getInput('config') || 'builder.json';\n    const cfg = await readJson(configFile);\n    if (!is.object(cfg)) {\n        throw new Error('missing-config');\n    }\n    // TODO: validation\n    if (!is.string(cfg.image)) {\n        cfg.image = getInput('image', { required: true });\n    }\n    if (!is.string(cfg.buildArg)) {\n        cfg.buildArg = cfg.image.toUpperCase() + '_VERSION';\n    }\n    await readDockerConfig(cfg);\n    const config = {\n        ...cfg,\n        imagePrefix: getArg('image-prefix')?.replace(/\\/$/, '') || 'renovate',\n        image: cfg.image,\n        depName: cfg.depName ?? cfg.image,\n        buildArg: cfg.buildArg,\n        buildArgs: getArg('build-args', { multi: true }),\n        tagSuffix: getArg('tag-suffix') || undefined,\n        ignoredVersions: cfg.ignoredVersions ?? [],\n        dryRun,\n        lastOnly: getInput('last-only') == 'true',\n        buildOnly: getInput('build-only') == 'true',\n        majorMinor: getArg('major-minor') !== 'false',\n        prune: getArg('prune') === 'true',\n        versioning: cfg.versioning ?? getDefaultVersioning(cfg.datasource),\n        platforms: getArg('platforms', { multi: true }),\n    };\n    if (dryRun) {\n        log('GitHub Actions branch detected - Force building latest, no push');\n        config.lastOnly = true;\n    }\n    log('config:', JSON.stringify(config));\n    const token = getArg('token');\n    if (token) {\n        addHostRule({ matchHost: 'github.com', token });\n    }\n    await init();\n    await generateImages(config);\n    log.info(chalk.blue('Processing done:', config.image));\n}\n","import * as fs from 'node:fs/promises';\nimport { join } from 'node:path';\nimport { ExecError } from './utils/types';\nimport { endGroup, getInput, startGroup } from '@actions/core';\nimport { exec as _exec } from '@actions/exec';\nimport { which } from '@actions/io';\nimport is from '@sindresorhus/is';\nimport * as findUp from 'find-up';\nconst DEFAULT_DISTRO = 'focal';\nexport async function exists(command) {\n    try {\n        await which(command, true);\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\nexport async function exec(cmd, args, options) {\n    let stdout = '';\n    let stderr = '';\n    let code;\n    try {\n        startGroup(`${cmd} ${args.join(' ')}`);\n        code = await _exec(cmd, args, {\n            ...options,\n            ignoreReturnCode: true,\n            listeners: {\n                stdout: (data) => {\n                    stdout += data.toString();\n                },\n                stderr: (data) => {\n                    stderr += data.toString();\n                },\n            },\n        });\n    }\n    finally {\n        endGroup();\n    }\n    if (code) {\n        throw new ExecError(code, stdout, stderr, `${cmd} ${args.join(' ')}`);\n    }\n    return { code, stdout, stderr };\n}\n/**\n * Get environment variable or empty string.\n * Used for easy mocking.\n * @param key variable name\n */\nexport function getEnv(key) {\n    return process.env[key] ?? '';\n}\nexport function isCI() {\n    return !!getEnv('CI');\n}\nexport function isDryRun() {\n    const val = getInput('dry-run') || getEnv('DRY_RUN');\n    return (!!val && val === 'true') || !isCI();\n}\nexport function getWorkspace() {\n    return getEnv('GITHUB_WORKSPACE') || process.cwd();\n}\nexport function getDistro() {\n    return getEnv('DISTRO') || getEnv('FLAVOR') || DEFAULT_DISTRO;\n}\nexport function getArch() {\n    return getEnv('ARCH');\n}\nexport async function readJson(file) {\n    const json = await readFile(file);\n    return JSON.parse(json);\n}\nexport async function readFile(file) {\n    const path = join(getWorkspace(), file);\n    return await fs.readFile(path, 'utf8');\n}\nexport async function readBuffer(file) {\n    const path = join(getWorkspace(), file);\n    return await fs.readFile(path);\n}\nexport async function writeFile(file, contents) {\n    const path = join(getWorkspace(), file);\n    await fs.writeFile(path, contents);\n}\nexport const MultiArgsSplitRe = /\\s*(?:[;,]|$)\\s*/;\nexport function getArg(name, opts) {\n    const val = getInput(name, opts);\n    return opts?.multi\n        ? val.split(MultiArgsSplitRe).filter(is.nonEmptyStringAndNotWhitespace)\n        : val;\n}\nlet _pkg;\n/**\n * Resolve path for a file relative to renovate root directory (our package.json)\n * @param file a file to resolve\n */\nexport async function resolveFile(file) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (!_pkg) {\n        _pkg = findUp('package.json', { cwd: __dirname, type: 'file' });\n    }\n    const pkg = await _pkg;\n    // istanbul ignore if\n    if (!pkg) {\n        throw new Error('Missing package.json');\n    }\n    return join(pkg, '../', file);\n}\n","import log from '../logger';\nimport { getDatasources } from 'renovate/dist/modules/datasource';\nexport function register() {\n    log('register datasources');\n    getDatasources();\n}\n","import { GenericVersioningApi, } from 'renovate/dist/modules/versioning/generic';\nimport { api as ubuntu } from 'renovate/dist/modules/versioning/ubuntu';\nconst versions = new Map([\n    ['bionic', { release: [18, 4] }],\n    ['focal', { release: [20, 4] }],\n]);\nexport const id = 'ubuntu';\nclass CustomUbuntuVersioning extends GenericVersioningApi {\n    _parse(version) {\n        let res = versions.get(version) ?? null;\n        if (!res && ubuntu.isValid(version)) {\n            res = { release: version.split('.').map((s) => parseInt(s, 10)) };\n        }\n        return res;\n    }\n    _compare(version1, version2) {\n        const parsed1 = this._parse(version1);\n        const parsed2 = this._parse(version2);\n        // istanbul ignore if\n        if (!parsed1 || !parsed2) {\n            return 1;\n        }\n        const length = Math.max(parsed1.release.length, parsed2.release.length);\n        for (let i = 0; i < length; i += 1) {\n            const part1 = parsed1.release[i];\n            const part2 = parsed2.release[i];\n            // shorter is bigger 2.1 > 2.1.1\n            // istanbul ignore if\n            if (part1 === undefined) {\n                return 1;\n            }\n            // istanbul ignore if\n            if (part2 === undefined) {\n                return -1;\n            }\n            if (part1 !== part2) {\n                return part1 - part2;\n            }\n        }\n        return 0;\n    }\n    isStable(version) {\n        return versions.has(version) || ubuntu.isStable(version);\n    }\n}\nexport const api = new CustomUbuntuVersioning();\nexport default api;\n","import log from '../logger';\nimport * as ubuntu from './ubuntu';\nimport { getVersionings } from 'renovate/dist/modules/versioning';\nexport function register() {\n    log('register versionings');\n    const ds = getVersionings();\n    ds.set(ubuntu.id, ubuntu.api);\n}\n","import * as renovate from './datasource';\nimport log from './logger';\nimport * as v from './versioning';\nexport function register() {\n    log('register renovate extensions');\n    renovate.register();\n    v.register();\n}\n","import log from './logger';\nimport * as renovate from './renovate';\nimport is from '@sindresorhus/is';\nimport { getPkgReleases, } from 'renovate/dist/modules/datasource';\nimport { get as getVersioning } from 'renovate/dist/modules/versioning';\nimport { add as addHostRule } from 'renovate/dist/util/host-rules';\nimport { configRegexPredicate } from 'renovate/dist/util/regex';\nimport * as semver from 'semver';\nrenovate.register();\nlet latestStable;\nexport { addHostRule };\nfunction getVersions(versions) {\n    return {\n        releases: versions.map((version) => ({\n            version,\n        })),\n    };\n}\nexport async function getBuildList({ allowedVersions, datasource, depName, lookupName, versioning, startVersion, ignoredVersions, lastOnly, forceUnstable, versions, latestVersion, maxVersions, extractVersion, }) {\n    log('Looking up versions');\n    const ver = getVersioning(versioning);\n    const pkgResult = versions\n        ? getVersions(versions)\n        : await getPkgReleases({\n            datasource,\n            packageName: lookupName ?? depName,\n            versioning,\n            extractVersion,\n        });\n    if (!pkgResult) {\n        return null;\n    }\n    let allVersions = pkgResult.releases\n        .map((v) => v.version)\n        .filter((v) => ver.isVersion(v) && ver.isCompatible(v, startVersion));\n    // filter duplicate versions (16.0.2+7 == 16.0.2+8)\n    allVersions = allVersions\n        .reverse()\n        .filter((v, i) => allVersions.findIndex((f) => ver.equals(f, v)) === i)\n        .reverse();\n    log(`Found ${allVersions.length} total versions`);\n    if (!allVersions.length) {\n        return null;\n    }\n    allVersions = allVersions\n        .filter((v) => v === startVersion || ver.isGreaterThan(v, startVersion))\n        .filter((v) => !ignoredVersions.includes(v));\n    if (!forceUnstable) {\n        log('Filter unstable versions');\n        allVersions = allVersions.filter((v) => ver.isStable(v));\n    }\n    if (is.string(allowedVersions)) {\n        const isAllowedPred = configRegexPredicate(allowedVersions);\n        if (isAllowedPred) {\n            allVersions = allVersions.filter((version) => isAllowedPred(version));\n        }\n        else if (ver.isValid(allowedVersions)) {\n            allVersions = allVersions.filter((version) => ver.matches(version, allowedVersions));\n        }\n        else if (semver.validRange(allowedVersions)) {\n            allVersions = allVersions.filter((v) => \n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            semver.satisfies(semver.coerce(v), allowedVersions));\n        }\n        else {\n            log.warn(`Invalid 'allowedVersions' options: ${allowedVersions}`);\n            return null;\n        }\n    }\n    if (!allVersions.length) {\n        log('Nothing to build');\n        return null;\n    }\n    log(`Found ${allVersions.length} versions within our range`);\n    log(`Candidates:`, allVersions.join(', '));\n    latestStable =\n        latestVersion ??\n            /* istanbul ignore next: not testable ts */\n            pkgResult.tags?.latest ??\n            allVersions.filter((v) => ver.isStable(v)).pop();\n    log('Latest stable version is', latestStable);\n    if (latestStable && !allVersions.includes(latestStable)) {\n        log.warn(`LatestStable '${latestStable}' not buildable, candidates:`, allVersions.join(', '));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastVersion = allVersions.at(-1);\n    log('Most recent version is', lastVersion);\n    if (is.number(maxVersions) && maxVersions > 0) {\n        log(`Building last ${maxVersions} version only`);\n        allVersions = allVersions.slice(-maxVersions);\n    }\n    if (lastOnly) {\n        log('Building last version only');\n        allVersions = [latestStable && !forceUnstable ? latestStable : lastVersion];\n    }\n    log('Build list:', allVersions.join(', '));\n    return { versions: allVersions, latestStable };\n}\n","import { getArch, getDistro, readFile } from '../util';\nimport { sumType } from './types';\nimport is from '@sindresorhus/is';\nimport * as escapeStringRegexp from 'escape-string-regexp';\nconst keys = [\n    'datasource',\n    'depName',\n    'lookupName',\n    'buildArg',\n    'versioning',\n    'latestVersion',\n];\nfunction checkArgs(cfg, groups) {\n    for (const key of keys) {\n        if (!is.string(cfg[key]) && is.nonEmptyString(groups[key])) {\n            cfg[key] = groups[key];\n        }\n    }\n}\nexport async function readDockerConfig(cfg) {\n    const buildArg = escapeStringRegexp(cfg.buildArg);\n    const dockerFileRe = new RegExp('# renovate: datasource=(?<datasource>[a-z-]+?) depName=(?<depName>.+?)(?: lookupName=(?<lookupName>.+?))?(?: versioning=(?<versioning>[a-z-]+?))?\\\\s' +\n        `(?:ENV|ARG) ${buildArg}=(?<latestVersion>.*)\\\\s`, 'g');\n    const dockerfile = await readFile('Dockerfile');\n    const m = dockerFileRe.exec(dockerfile);\n    if (m && m.groups) {\n        checkArgs(cfg, m.groups);\n    }\n}\nexport function getBinaryName(cfg, version, sum) {\n    const arch = getArch();\n    const ext = sum ? `.${sumType}` : '';\n    if (is.nonEmptyString(arch)) {\n        return `${cfg.image}-${version}-${getDistro()}-${arch}.tar.xz${ext}`;\n    }\n    return `${cfg.image}-${version}-${getDistro()}.tar.xz${ext}`;\n}\n","import log from '../logger';\nimport { docker, dockerBuildx, dockerRun } from './common';\nconst SupportedPlatforms = 'arm64';\nexport async function init(use) {\n    const buildx = await dockerBuildx('ls');\n    if (buildx.stdout.includes('renovatebot-builder')) {\n        log('Buildx already initialized');\n        process.env.BUILDX_BUILDER = 'renovatebot-builder';\n        return;\n    }\n    log.info('Configure buildx');\n    await docker('info');\n    // install emulations\n    // https://github.com/docker/setup-qemu-action/blob/9d419fda7df46b2bcd38fadda3ec44f4748d25e1/src/main.ts#L22\n    await dockerRun('--privileged', 'tonistiigi/binfmt', '--install', SupportedPlatforms);\n    await dockerBuildx('version');\n    await dockerBuildx('create', '--name', 'renovatebot-builder', '--driver', 'docker-container');\n    // istanbul ignore if\n    if (use) {\n        await dockerBuildx('use', 'renovatebot-builder');\n    }\n    await dockerBuildx('inspect', '--bootstrap', 'renovatebot-builder');\n    process.env.BUILDX_BUILDER = 'renovatebot-builder';\n    await dockerBuildx('ls');\n}\n","import { exec } from '../../util';\nimport log from '../logger';\nexport var DockerPlatform;\n(function (DockerPlatform) {\n    DockerPlatform[\"x86_64\"] = \"linux/amd64\";\n    DockerPlatform[\"aarch64\"] = \"linux/arm64\";\n})(DockerPlatform || (DockerPlatform = {}));\nexport async function docker(...args) {\n    return await exec('docker', [...args]);\n}\nexport async function dockerRun(...args) {\n    await docker('run', '--rm', ...args);\n}\nexport async function dockerBuildx(...args) {\n    return await docker('buildx', ...args);\n}\nexport async function dockerPrune() {\n    log('Pruning docker system');\n    await docker('system', 'prune', '--force', '--all');\n}\nexport async function dockerDf() {\n    log('Docker system disk usage');\n    await docker('system', 'df');\n}\n","export class ExecError extends Error {\n    code;\n    stdout;\n    stderr;\n    cmd;\n    name = 'ExecError';\n    constructor(code, stdout, stderr, cmd) {\n        super(`ExecError: (${code}) ` + stderr.split('\\n').slice(-10).join('\\n'));\n        this.code = code;\n        this.stdout = stdout;\n        this.stderr = stderr;\n        this.cmd = cmd;\n    }\n}\nexport const sumType = 'sha512';\n"],"names":[],"sourceRoot":""}