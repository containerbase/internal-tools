{"version":3,"file":"393.index.js","sources":["webpack:///../node_modules/delay/index.js","webpack:///./utils/docker.ts","webpack:///./utils/datasource/index.ts","webpack:///./utils/versioning/ubuntu.ts","webpack:///./utils/versioning/index.ts","webpack:///./utils/renovate.ts","webpack:///./commands/docker/builder.ts","webpack:///./util.ts","webpack:///./utils/config.ts","webpack:///./utils/docker/buildx.ts","webpack:///./utils/docker/common.ts","webpack:///./utils/types.ts"],"sourcesContent":["'use strict';\n\n// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15\nconst randomInteger = (minimum, maximum) => Math.floor((Math.random() * (maximum - minimum + 1)) + minimum);\n\nconst createAbortError = () => {\n\tconst error = new Error('Delay aborted');\n\terror.name = 'AbortError';\n\treturn error;\n};\n\nconst createDelay = ({clearTimeout: defaultClear, setTimeout: set, willResolve}) => (ms, {value, signal} = {}) => {\n\tif (signal && signal.aborted) {\n\t\treturn Promise.reject(createAbortError());\n\t}\n\n\tlet timeoutId;\n\tlet settle;\n\tlet rejectFn;\n\tconst clear = defaultClear || clearTimeout;\n\n\tconst signalListener = () => {\n\t\tclear(timeoutId);\n\t\trejectFn(createAbortError());\n\t};\n\n\tconst cleanup = () => {\n\t\tif (signal) {\n\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t}\n\t};\n\n\tconst delayPromise = new Promise((resolve, reject) => {\n\t\tsettle = () => {\n\t\t\tcleanup();\n\t\t\tif (willResolve) {\n\t\t\t\tresolve(value);\n\t\t\t} else {\n\t\t\t\treject(value);\n\t\t\t}\n\t\t};\n\n\t\trejectFn = reject;\n\t\ttimeoutId = (set || setTimeout)(settle, ms);\n\t});\n\n\tif (signal) {\n\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t}\n\n\tdelayPromise.clear = () => {\n\t\tclear(timeoutId);\n\t\ttimeoutId = null;\n\t\tsettle();\n\t};\n\n\treturn delayPromise;\n};\n\nconst createWithTimers = clearAndSet => {\n\tconst delay = createDelay({...clearAndSet, willResolve: true});\n\tdelay.reject = createDelay({...clearAndSet, willResolve: false});\n\tdelay.range = (minimum, maximum, options) => delay(randomInteger(minimum, maximum), options);\n\treturn delay;\n};\n\nconst delay = createWithTimers();\ndelay.createWithTimers = createWithTimers;\n\nmodule.exports = delay;\n// TODO: Remove this for the next major release\nmodule.exports.default = delay;\n","import is from '@sindresorhus/is';\nimport * as chalk from 'chalk';\nimport * as delay from 'delay';\nimport got, { HTTPError } from 'got';\nimport * as wwwAuthenticate from 'www-authenticate';\nimport { docker } from './docker/common';\nimport log from './logger';\nimport { ExecError } from './types';\nexport const registry = 'https://index.docker.io';\nexport async function getAuthHeaders(registry, repository) {\n    try {\n        const apiCheckUrl = `${registry}/v2/`;\n        const apiCheckResponse = await got(apiCheckUrl, { throwHttpErrors: false });\n        if (apiCheckResponse.headers['www-authenticate'] === undefined) {\n            return {};\n        }\n        const authenticateHeader = new wwwAuthenticate.parsers.WWW_Authenticate(apiCheckResponse.headers['www-authenticate']);\n        const authUrl = `${authenticateHeader.parms.realm}?service=${authenticateHeader.parms.service}&scope=repository:${repository}:pull`;\n        const authResponse = (await got(authUrl, {\n            responseType: 'json',\n        })).body;\n        const token = authResponse.token || authResponse.access_token;\n        if (!token) {\n            throw new Error('Failed to obtain docker registry token');\n        }\n        return {\n            authorization: `Bearer ${token}`,\n        };\n    }\n    catch (err) {\n        log.error(chalk.red('auth error'), err.message);\n        throw new Error('Failed to obtain docker registry token');\n    }\n}\nexport var DockerContentType;\n(function (DockerContentType) {\n    DockerContentType[\"ManifestV1\"] = \"application/vnd.docker.distribution.manifest.v1+json\";\n    DockerContentType[\"ManifestV1Signed\"] = \"application/vnd.docker.distribution.manifest.v1+prettyjws\";\n    DockerContentType[\"ManifestV2\"] = \"application/vnd.docker.distribution.manifest.v2+json\";\n})(DockerContentType || (DockerContentType = {}));\nconst shaRe = /(sha256:[a-f0-9]{64})/;\nexport async function getRemoteImageId(repository, tag = 'latest') {\n    const headers = await getAuthHeaders(registry, repository);\n    headers.accept = DockerContentType.ManifestV2;\n    const url = `${registry}/v2/${repository}/manifests/${tag}`;\n    try {\n        const resp = await got(url, {\n            headers,\n            responseType: 'json',\n        });\n        switch (resp.headers['content-type']) {\n            case DockerContentType.ManifestV2:\n                return resp.body.config.digest;\n            case DockerContentType.ManifestV1:\n            case DockerContentType.ManifestV1Signed:\n                // something wrong, we need to overwrite existing\n                log.warn(chalk.yellow('Wrong response'), `Wrong response: ${resp.headers['content-type']}`);\n                return '<error>';\n            default:\n                throw new Error(`Unsupported response: ${resp.headers['content-type']}`);\n        }\n    }\n    catch (e) {\n        if (e instanceof HTTPError && e.response.statusCode === 404) {\n            // no image published yet\n            return '<none>';\n        }\n        log.error(chalk.red('request error'), e.message);\n        throw new Error('Could not find remote image id');\n    }\n}\nexport async function getLocalImageId(image, tag = 'latest') {\n    var _a;\n    const res = await docker('inspect', \"--format='{{.Id}}'\", `${image}:${tag}`);\n    const [, id] = (_a = shaRe.exec(res.stdout)) !== null && _a !== void 0 ? _a : [];\n    if (!id) {\n        log.error(res);\n        throw new Error('Could not find local image id');\n    }\n    return id;\n}\nconst errors = [\n    'unexpected status: 400 Bad Request',\n    ': no response',\n    'error writing layer blob',\n];\nfunction canRetry(err) {\n    return errors.some((str) => err.stderr.includes(str));\n}\nexport async function build({ image, imagePrefix, cache, cacheTags, tag = 'latest', dryRun, buildArgs, }) {\n    const args = [\n        'buildx',\n        'build',\n        '--load',\n        `--tag=${imagePrefix}/${image}:${tag}`,\n    ];\n    if (is.nonEmptyArray(buildArgs)) {\n        args.push(...buildArgs.map((b) => `--build-arg=${b}`));\n    }\n    if (is.string(cache)) {\n        const cacheImage = `${imagePrefix}/${cache}:${image.replace(/\\//g, '-')}`;\n        args.push(`--cache-from=${cacheImage}-${tag}`);\n        if (is.nonEmptyArray(cacheTags)) {\n            for (const ctag of cacheTags) {\n                args.push(`--cache-from=${cacheImage}-${ctag}`);\n            }\n        }\n        if (!dryRun) {\n            args.push(`--cache-to=type=registry,ref=${cacheImage}-${tag},mode=max`);\n        }\n    }\n    for (let build = 0;; build++) {\n        try {\n            await docker(...args, '.');\n            break;\n        }\n        catch (e) {\n            if (e instanceof ExecError && canRetry(e) && build < 2) {\n                log.error(chalk.red(`docker build error on try ${build}`), e);\n                await delay(5000);\n                continue;\n            }\n            throw e;\n        }\n    }\n}\nexport async function publish({ image, imagePrefix, tag, dryRun, }) {\n    const imageName = `${imagePrefix}/${image}`;\n    const fullName = `${imageName}:${tag}`;\n    log.info(chalk.blue('Processing image:'), chalk.yellow(fullName));\n    log('Fetch new id');\n    const newId = await getLocalImageId(imageName, tag);\n    log('Fetch old id');\n    const oldId = await getRemoteImageId(imageName, tag);\n    if (oldId === newId) {\n        log('Image uptodate, no push nessessary:', chalk.yellow(oldId));\n        return;\n    }\n    log('Publish new image', `${oldId} => ${newId}`);\n    if (dryRun) {\n        log.warn(chalk.yellow('[DRY_RUN]'), chalk.blue('Would push:'), fullName);\n    }\n    else {\n        await docker('push', fullName);\n    }\n    log.info(chalk.blue('Processing image finished:', newId));\n}\n","import { getDatasources } from 'renovate/dist/datasource';\nimport log from '../logger';\nexport function register() {\n    log('register datasources');\n    getDatasources();\n}\n","import * as generic from 'renovate/dist/versioning/loose/generic';\nconst versions = new Map([\n    ['bionic', { release: [18, 4] }],\n    ['18.04', { release: [18, 4] }],\n    ['focal', { release: [20, 4] }],\n    ['20.04', { release: [20, 4] }],\n]);\nexport const id = 'ubuntu';\nfunction parse(version) {\n    return versions.get(version);\n}\nfunction compare(version1, version2) {\n    const parsed1 = parse(version1);\n    const parsed2 = parse(version2);\n    // istanbul ignore if\n    if (!parsed1 || !parsed2) {\n        return 1;\n    }\n    const length = Math.max(parsed1.release.length, parsed2.release.length);\n    for (let i = 0; i < length; i += 1) {\n        const part1 = parsed1.release[i];\n        const part2 = parsed2.release[i];\n        // shorter is bigger 2.1 > 2.1.1\n        // istanbul ignore if\n        if (part1 === undefined) {\n            return 1;\n        }\n        // istanbul ignore if\n        if (part2 === undefined) {\n            return -1;\n        }\n        if (part1 !== part2) {\n            return part1 - part2;\n        }\n    }\n    return 0;\n}\nfunction isCompatible(version, range) {\n    const parsed1 = parse(version);\n    const parsed2 = parse(range);\n    return parsed1 != null && parsed2 != null;\n}\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nexport const api = {\n    ...generic.create({\n        parse,\n        compare,\n    }),\n    isCompatible,\n};\nexport default api;\n","import { getVersionings } from 'renovate/dist/versioning';\nimport log from '../logger';\nimport * as ubuntu from './ubuntu';\nexport function register() {\n    log('register versionings');\n    const ds = getVersionings();\n    ds.set(ubuntu.id, ubuntu.api);\n}\n","import * as renovate from './datasource';\nimport log from './logger';\nimport * as v from './versioning';\nexport function register() {\n    log('register renovate extensions');\n    renovate.register();\n    v.register();\n}\n","import { getInput, setFailed } from '@actions/core';\nimport is from '@sindresorhus/is';\nimport * as chalk from 'chalk';\nimport { getPkgReleases } from 'renovate/dist/datasource';\nimport { get as getVersioning } from 'renovate/dist/versioning';\nimport { exec, getArg, isDryRun, readJson } from '../../util';\nimport { readDockerConfig } from '../../utils/config';\nimport { build, publish } from '../../utils/docker';\nimport { init } from '../../utils/docker/buildx';\nimport { dockerDf, dockerPrune, dockerTag } from '../../utils/docker/common';\nimport log from '../../utils/logger';\nimport * as renovate from '../../utils/renovate';\nrenovate.register();\nexport const MultiArgsSplitRe = /\\s*(?:[;,]|$)\\s*/;\nlet latestStable;\nfunction getVersions(versions) {\n    return {\n        releases: versions.map((version) => ({\n            version,\n        })),\n    };\n}\nasync function getBuildList({ datasource, depName, versioning, startVersion, ignoredVersions, lastOnly, forceUnstable, versions, latestVersion, maxVersions, extractVersion, }) {\n    var _a;\n    log('Looking up versions');\n    const ver = getVersioning(versioning);\n    const pkgResult = versions\n        ? getVersions(versions)\n        : await getPkgReleases({\n            datasource,\n            depName,\n            versioning,\n            extractVersion,\n        });\n    if (!pkgResult) {\n        return [];\n    }\n    let allVersions = pkgResult.releases\n        .map((v) => v.version)\n        .filter((v) => ver.isVersion(v) && ver.isCompatible(v, startVersion));\n    log(`Found ${allVersions.length} total versions`);\n    if (!allVersions.length) {\n        return [];\n    }\n    allVersions = allVersions\n        .filter((v) => v === startVersion || ver.isGreaterThan(v, startVersion))\n        .filter((v) => !ignoredVersions.includes(v));\n    if (!forceUnstable) {\n        log('Filter unstable versions');\n        allVersions = allVersions.filter((v) => ver.isStable(v));\n    }\n    log(`Found ${allVersions.length} versions within our range`);\n    log(`Candidates:`, allVersions.join(', '));\n    latestStable =\n        latestVersion ||\n            (\n            /* istanbul ignore next: not testable ts */\n            (_a = pkgResult.tags) === null || _a === void 0 ? void 0 : _a.latest) ||\n            allVersions.filter((v) => ver.isStable(v)).pop();\n    log('Latest stable version is', latestStable);\n    if (latestStable && !allVersions.includes(latestStable)) {\n        log.warn(`LatestStable '${latestStable}' not buildable, candidates:`, allVersions.join(', '));\n    }\n    const lastVersion = allVersions[allVersions.length - 1];\n    log('Most recent version is', lastVersion);\n    if (is.number(maxVersions) && maxVersions > 0) {\n        log(`Building last ${maxVersions} version only`);\n        allVersions = allVersions.slice(-maxVersions);\n    }\n    if (lastOnly) {\n        log('Building last version only');\n        allVersions = [latestStable && !forceUnstable ? latestStable : lastVersion];\n    }\n    if (allVersions.length) {\n        log('Build list:', allVersions.join(', '));\n    }\n    else {\n        log('Nothing to build');\n    }\n    return allVersions;\n}\nfunction createTag(tagSuffix, version) {\n    return is.nonEmptyString(tagSuffix) && tagSuffix !== 'latest'\n        ? `${version}-${tagSuffix}`\n        : version;\n}\nasync function buildAndPush({ imagePrefix, image, buildArg, buildArgs, buildOnly, cache, dryRun, tagSuffix, versioning, majorMinor, prune, }, versions) {\n    const builds = [];\n    const failed = [];\n    const ver = getVersioning(versioning || 'semver');\n    const versionsMap = new Map();\n    if (majorMinor) {\n        for (const version of versions) {\n            const minor = ver.getMinor(version);\n            const major = ver.getMajor(version);\n            const isStable = ver.isStable(version);\n            if (isStable && is.number(major) && `${major}` !== version) {\n                versionsMap.set(`${major}`, version);\n            }\n            if (isStable &&\n                is.number(major) &&\n                is.number(minor) &&\n                `${major}.${minor}` !== version) {\n                versionsMap.set(`${major}.${minor}`, version);\n            }\n        }\n    }\n    await exec('df', ['-h']);\n    for (const version of versions) {\n        const tag = createTag(tagSuffix, version);\n        const imageVersion = `${imagePrefix}/${image}:${tag}`;\n        log(`Building ${imageVersion}`);\n        try {\n            const minor = ver.getMinor(version);\n            const major = ver.getMajor(version);\n            const cacheTags = [tagSuffix !== null && tagSuffix !== void 0 ? tagSuffix : 'latest'];\n            const tags = [];\n            if (is.number(major) &&\n                majorMinor &&\n                versionsMap.get(`${major}`) === version) {\n                const nTag = createTag(tagSuffix, `${major}`);\n                cacheTags.push(nTag);\n                tags.push(nTag);\n            }\n            if (is.number(major) &&\n                is.number(minor) &&\n                majorMinor &&\n                versionsMap.get(`${major}.${minor}`) === version) {\n                const nTag = createTag(tagSuffix, `${major}.${minor}`);\n                cacheTags.push(nTag);\n                tags.push(nTag);\n            }\n            if (version === latestStable) {\n                tags.push(tagSuffix !== null && tagSuffix !== void 0 ? tagSuffix : 'latest');\n            }\n            await build({\n                image,\n                imagePrefix,\n                tag,\n                cache,\n                cacheTags,\n                buildArgs: [...(buildArgs !== null && buildArgs !== void 0 ? buildArgs : []), `${buildArg}=${version}`],\n                dryRun,\n            });\n            if (!buildOnly) {\n                await publish({ image, imagePrefix, tag, dryRun });\n                const source = tag;\n                for (const tag of tags) {\n                    log(`Publish ${source} as ${tag}`);\n                    await dockerTag({ image, imagePrefix, src: source, tgt: tag });\n                    await publish({ image, imagePrefix, tag, dryRun });\n                }\n            }\n            log(`Build ${imageVersion}`);\n            builds.push(version);\n        }\n        catch (err) {\n            log.error(err);\n            failed.push(version);\n        }\n        await dockerDf();\n        await exec('df', ['-h']);\n        if (prune) {\n            await dockerPrune();\n            await exec('df', ['-h']);\n        }\n    }\n    if (builds.length) {\n        log('Build list:' + builds.join(' '));\n    }\n    if (failed.length) {\n        log.warn('Failed list:' + failed.join(' '));\n        throw new Error('failed');\n    }\n}\nasync function generateImages(config) {\n    const buildList = await getBuildList(config);\n    if (buildList.length === 0) {\n        setFailed(`No versions found.`);\n        return;\n    }\n    await buildAndPush(config, buildList);\n}\nexport async function run() {\n    var _a, _b, _c;\n    const dryRun = isDryRun();\n    const configFile = getInput('config') || 'builder.json';\n    const cfg = await readJson(configFile);\n    if (!is.object(cfg)) {\n        throw new Error('missing-config');\n    }\n    // TODO: validation\n    if (!is.string(cfg.image)) {\n        cfg.image = getInput('image', { required: true });\n    }\n    if (!is.string(cfg.buildArg)) {\n        cfg.buildArg = cfg.image.toUpperCase() + '_VERSION';\n    }\n    await readDockerConfig(cfg);\n    const config = {\n        ...cfg,\n        imagePrefix: ((_a = getArg('image-prefix')) === null || _a === void 0 ? void 0 : _a.replace(/\\/$/, '')) || 'renovate',\n        image: cfg.image,\n        depName: (_b = cfg.depName) !== null && _b !== void 0 ? _b : cfg.image,\n        buildArg: cfg.buildArg,\n        buildArgs: getArg('build-args', { multi: true }),\n        tagSuffix: getArg('tag-suffix') || undefined,\n        ignoredVersions: (_c = cfg.ignoredVersions) !== null && _c !== void 0 ? _c : [],\n        dryRun,\n        lastOnly: getInput('last-only') == 'true',\n        buildOnly: getInput('build-only') == 'true',\n        majorMinor: getArg('major-minor') !== 'false',\n        prune: getArg('prune') === 'true',\n    };\n    if (dryRun) {\n        log('GitHub Actions branch detected - Force building latest, no push');\n        config.lastOnly = true;\n    }\n    log('config:', JSON.stringify(config));\n    await init();\n    await generateImages(config);\n    log.info(chalk.blue('Processing done:', config.image));\n}\n","import { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { endGroup, getInput, startGroup } from '@actions/core';\nimport { exec as _exec } from '@actions/exec';\nimport * as findUp from 'find-up';\nimport { ExecError } from './utils/types';\nconst DEFAULT_DISTRO = 'focal';\n/** webpack workaround for dynamic require */\nconst _require = eval('require');\nfunction _import(path) {\n    return Promise.resolve(_require(path));\n}\nexport async function exec(cmd, args, options) {\n    let stdout = '';\n    let stderr = '';\n    let code;\n    try {\n        startGroup(`${cmd} ${args.join(' ')}`);\n        code = await _exec(cmd, args, {\n            ...options,\n            ignoreReturnCode: true,\n            listeners: {\n                stdout: (data) => {\n                    stdout += data.toString();\n                },\n                stderr: (data) => {\n                    stderr += data.toString();\n                },\n            },\n        });\n    }\n    finally {\n        endGroup();\n    }\n    if (code) {\n        throw new ExecError(code, stdout, stderr, `${cmd} ${args.join(' ')}`);\n    }\n    return { code, stdout, stderr };\n}\n/**\n * Get environment variable or empty string.\n * Used for easy mocking.\n * @param key variable name\n */\nexport function getEnv(key) {\n    var _a;\n    return (_a = process.env[key]) !== null && _a !== void 0 ? _a : '';\n}\nexport function isCI() {\n    return !!getEnv('CI');\n}\nexport function isDryRun() {\n    const val = getInput('dry-run') || getEnv('DRY_RUN');\n    return (!!val && val === 'true') || !isCI();\n}\nexport function getWorkspace() {\n    return getEnv('GITHUB_WORKSPACE') || process.cwd();\n}\nexport function getDistro() {\n    return getEnv('DISTRO') || getEnv('FLAVOR') || DEFAULT_DISTRO;\n}\nexport function getArch() {\n    return getEnv('ARCH');\n}\nexport async function readJson(file) {\n    const path = join(getWorkspace(), file);\n    const res = await _import(path);\n    // istanbul ignore next\n    return 'default' in res ? res === null || res === void 0 ? void 0 : res.default : res;\n}\nexport async function readFile(file) {\n    const path = join(getWorkspace(), file);\n    return await fs.readFile(path, 'utf8');\n}\nexport async function readBuffer(file) {\n    const path = join(getWorkspace(), file);\n    return await fs.readFile(path);\n}\nexport const MultiArgsSplitRe = /\\s*(?:[;,]|$)\\s*/;\nexport function getArg(name, opts) {\n    const val = getInput(name, opts);\n    return (opts === null || opts === void 0 ? void 0 : opts.multi) ? val.split(MultiArgsSplitRe).filter(Boolean) : val;\n}\nlet _pkg;\n/**\n * Resolve path for a file relative to renovate root directory (our package.json)\n * @param file a file to resolve\n */\nexport async function resolveFile(file) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (!_pkg) {\n        _pkg = findUp('package.json', { cwd: __dirname, type: 'file' });\n    }\n    const pkg = await _pkg;\n    // istanbul ignore if\n    if (!pkg) {\n        throw new Error('Missing package.json');\n    }\n    return join(pkg, '../', file);\n}\n","import is from '@sindresorhus/is';\nimport { readFile } from '../util';\nconst keys = [\n    'datasource',\n    'depName',\n    'buildArg',\n    'versioning',\n    'latestVersion',\n];\nfunction checkArgs(cfg, groups) {\n    for (const key of keys) {\n        if (!is.string(cfg[key]) && is.nonEmptyString(groups[key])) {\n            cfg[key] = groups[key];\n        }\n    }\n}\nexport async function readDockerConfig(cfg) {\n    const dockerFileRe = new RegExp('# renovate: datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?\\\\s' +\n        `(?:ENV|ARG) ${cfg.buildArg}=(?<latestVersion>.*)\\\\s`, 'g');\n    const dockerfile = await readFile('Dockerfile');\n    const m = dockerFileRe.exec(dockerfile);\n    if (m && m.groups) {\n        checkArgs(cfg, m.groups);\n    }\n}\n","import log from '../logger';\nimport { docker, dockerBuildx, dockerRun } from './common';\nconst SupportedPlatforms = 'arm64';\nexport async function init() {\n    const buildx = await dockerBuildx('ls');\n    if (buildx.stdout.includes('renovatebot-builder')) {\n        log('Buildx already initialized');\n        return;\n    }\n    log.info('Configure buildx');\n    await docker('info');\n    // install emulations\n    // https://github.com/docker/setup-qemu-action/blob/9d419fda7df46b2bcd38fadda3ec44f4748d25e1/src/main.ts#L22\n    await dockerRun('--privileged', 'tonistiigi/binfmt', '--install', SupportedPlatforms);\n    await dockerBuildx('version');\n    await dockerBuildx('create', '--name', 'renovatebot-builder', '--driver', 'docker-container', '--use');\n    await dockerBuildx('inspect', '--bootstrap');\n}\n","import { exec } from '../../util';\nimport log from '../logger';\nexport var DockerPlatform;\n(function (DockerPlatform) {\n    DockerPlatform[\"x86_64\"] = \"linux/amd64\";\n    DockerPlatform[\"aarch64\"] = \"linux/arm64\";\n})(DockerPlatform || (DockerPlatform = {}));\nexport async function docker(...args) {\n    return await exec('docker', [...args]);\n}\nexport async function dockerRun(...args) {\n    await docker('run', '--rm', ...args);\n}\nexport async function dockerBuildx(...args) {\n    return await docker('buildx', ...args);\n}\nexport async function dockerTag({ image, imagePrefix, src, tgt, }) {\n    return await exec('docker', [\n        'tag',\n        `${imagePrefix}/${image}:${src}`,\n        `${imagePrefix}/${image}:${tgt}`,\n    ]);\n}\nexport async function dockerPrune() {\n    log('Pruning docker system');\n    await docker('system', 'prune', '--force', '--all');\n}\nexport async function dockerDf() {\n    log('Docker system disk usage');\n    await docker('system', 'df');\n}\n","export class ExecError extends Error {\n    constructor(code, stdout, stderr, cmd) {\n        super(`ExecError: (${code}) ` + stderr.split('\\n').slice(-10).join('\\n'));\n        this.code = code;\n        this.stdout = stdout;\n        this.stderr = stderr;\n        this.cmd = cmd;\n        this.name = 'ExecError';\n    }\n}\n"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;A","sourceRoot":""}