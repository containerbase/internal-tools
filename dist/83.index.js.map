{"version":3,"file":"83.index.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./utils/github.ts","webpack:///./utils/sum.ts","webpack:///./commands/binary/utils.ts","webpack:///./commands/binary/index.ts","webpack:///./util.ts","webpack:///./utils/datasource/index.ts","webpack:///./utils/versioning/ubuntu.ts","webpack:///./utils/versioning/index.ts","webpack:///./utils/renovate.ts","webpack:///./utils/builds.ts","webpack:///./utils/config.ts","webpack:///./utils/docker/buildx.ts","webpack:///./utils/docker/common.ts","webpack:///./utils/types.ts"],"sourcesContent":["// istanbul ignore file\nimport { setTimeout } from 'node:timers/promises';\nimport { readBuffer, writeFile } from '../util';\nimport { getBinaryName } from './config';\nimport log from './logger';\nimport { context, getOctokit } from '@actions/github';\nimport got from 'got';\nexport { getOctokit };\nlet releaseCache = null;\nfunction getBody(cfg, version) {\n    return `### Bug Fixes\n\n* **deps:** update dependency ${cfg.image} to v${version}`;\n}\nfunction isRequestError(err) {\n    return err instanceof Error && 'status' in err;\n}\nasync function findRelease(api, version) {\n    try {\n        if (!releaseCache) {\n            const cache = new Map();\n            const rels = await api.paginate(api.rest.repos.listReleases, {\n                ...context.repo,\n                per_page: 100,\n            });\n            for (const rel of rels) {\n                cache.set(rel.tag_name, rel);\n            }\n            releaseCache = cache;\n        }\n        return releaseCache.get(version) ?? null;\n    }\n    catch (e) {\n        if (isRequestError(e) && e.status !== 404) {\n            throw e;\n        }\n    }\n    return null;\n}\nasync function getRelease(api, version) {\n    try {\n        const { data } = await api.rest.repos.getReleaseByTag({\n            ...context.repo,\n            tag: version,\n        });\n        releaseCache?.set(version, data);\n        return data;\n    }\n    catch (err) {\n        if (isRequestError(err) && err.status == 404) {\n            return null;\n        }\n        throw err;\n    }\n}\nasync function createRelease(api, cfg, version, retry = true) {\n    try {\n        let data = await getRelease(api, version);\n        if (data) {\n            return data;\n        }\n        ({ data } = await api.rest.repos.createRelease({\n            ...context.repo,\n            tag_name: version,\n            name: version,\n            body: getBody(cfg, version),\n        }));\n        releaseCache?.set(version, data);\n        return data;\n    }\n    catch (err) {\n        if (retry &&\n            isRequestError(err) &&\n            err.status == 422 &&\n            err.response?.data) {\n            log('Release probably created by other process, retrying:', version, err.message);\n            await setTimeout(250);\n            return await createRelease(api, cfg, version, false);\n        }\n        throw err;\n    }\n}\nexport async function updateRelease(api, cfg, version) {\n    const body = getBody(cfg, version);\n    const rel = await findRelease(api, version);\n    if (rel == null || (rel.name === version && rel.body === body)) {\n        return;\n    }\n    const { data } = await api.rest.repos.updateRelease({\n        ...context.repo,\n        release_id: rel.id,\n        name: version,\n        body,\n    });\n    releaseCache?.set(data.tag_name, data);\n}\nexport async function uploadAsset(api, cfg, version, sum) {\n    try {\n        let rel = await findRelease(api, version);\n        let release_id = rel?.id ?? 0;\n        if (rel == null) {\n            rel = await createRelease(api, cfg, version);\n            release_id = rel.id;\n        }\n        const name = getBinaryName(cfg, version, sum);\n        const buffer = await readBuffer(`.cache/${name}`);\n        const { data } = await api.rest.repos.uploadReleaseAsset({\n            ...context.repo,\n            release_id,\n            url: rel.upload_url,\n            // fake because api issues https://github.com/octokit/octokit.js/discussions/2087\n            data: buffer,\n            name,\n            headers: {\n                'content-type': 'application/octet-stream',\n                'content-length': buffer.length,\n            },\n        });\n        // cache asset\n        rel.assets.push(data);\n    }\n    catch (e) {\n        if (isRequestError(e) && e.status !== 404) {\n            throw e;\n        }\n    }\n}\nexport async function hasAsset(api, cfg, version, sum) {\n    return (await findAsset(api, cfg, version, sum)) != null;\n}\nexport async function findAsset(api, cfg, version, sum) {\n    const rel = await findRelease(api, version);\n    const name = getBinaryName(cfg, version, sum);\n    return rel?.assets.find((a) => a.name === name) ?? null;\n}\nexport async function downloadAsset(api, cfg, version) {\n    const asset = await findAsset(api, cfg, version);\n    if (!asset) {\n        return false;\n    }\n    try {\n        const buffer = await got({\n            url: asset.browser_download_url,\n            responseType: 'buffer',\n            resolveBodyOnly: true,\n        });\n        if (buffer.length != asset.size) {\n            log.error('Wrong binary size');\n            return false;\n        }\n        const name = getBinaryName(cfg, version);\n        await writeFile(`.cache/${name}`, buffer);\n    }\n    catch (e) {\n        // eslint-disable-next-line\n        log(`Version ${version} failed: ${e.message}`, e.stack);\n        return false;\n    }\n    return true;\n}\n","import { createHash } from 'node:crypto';\nimport { readBuffer, writeFile } from '../util';\nimport { getBinaryName } from './config';\nimport { sumType } from './types';\nexport function hash(file) {\n    return createHash(sumType).update(file).digest('hex');\n}\nexport async function createChecksum(cfg, version) {\n    const name = getBinaryName(cfg, version);\n    const sumName = getBinaryName(cfg, version, true);\n    const buffer = await readBuffer(`.cache/${name}`);\n    const sum = hash(buffer);\n    await writeFile(`.cache/${sumName}`, sum);\n}\n","import { getArch, getArg, getDistro, isDryRun, readJson } from '../../util';\nimport { readDockerConfig } from '../../utils/config';\nimport { DockerPlatform, dockerBuildx, dockerRun, } from '../../utils/docker/common';\nimport log from '../../utils/logger';\nimport { getInput } from '@actions/core';\nimport is from '@sindresorhus/is';\nimport { getDefaultVersioning } from 'renovate/dist/modules/datasource';\nexport async function getConfig() {\n    const configFile = getInput('config') || 'builder.json';\n    const cfg = await readJson(configFile);\n    if (!is.object(cfg)) {\n        throw new Error('missing-config');\n    }\n    if (!is.string(cfg.image)) {\n        cfg.image = getInput('image', { required: true });\n    }\n    if (!is.string(cfg.buildArg)) {\n        cfg.buildArg = cfg.image.toUpperCase() + '_VERSION';\n    }\n    await readDockerConfig(cfg);\n    return {\n        ...cfg,\n        ignoredVersions: cfg.ignoredVersions ?? [],\n        dryRun: isDryRun(),\n        lastOnly: getArg('last-only') == 'true',\n        buildArgs: getArg('build-args', { multi: true }),\n        versioning: cfg.versioning ?? getDefaultVersioning(cfg.datasource),\n    };\n}\nexport async function createBuilderImage(ws, { buildArgs }) {\n    log('Creating builder image');\n    const args = [\n        'build',\n        '--load',\n        '-t',\n        'builder',\n        '--build-arg',\n        `DISTRO=${getDistro()}`,\n    ];\n    const arch = getArch();\n    if (is.nonEmptyString(arch)) {\n        args.push('--platform', DockerPlatform[arch]);\n    }\n    if (is.nonEmptyArray(buildArgs)) {\n        args.push(...buildArgs.map((b) => `--build-arg=${b}`));\n    }\n    await dockerBuildx(...args, ws);\n}\nexport async function runBuilder(ws, version) {\n    const args = ['--name', 'builder', '--volume', `${ws}/.cache:/cache`];\n    const arch = getArch();\n    if (is.nonEmptyString(arch)) {\n        args.push('--platform', DockerPlatform[arch]);\n    }\n    await dockerRun(...args, 'builder', version);\n}\n","import { getArg, getWorkspace } from '../../util';\nimport { addHostRule, getBuildList } from '../../utils/builds';\nimport { init } from '../../utils/docker/buildx';\nimport { downloadAsset, getOctokit, hasAsset, updateRelease, uploadAsset, } from '../../utils/github';\nimport log from '../../utils/logger';\nimport { createChecksum } from '../../utils/sum';\nimport { createBuilderImage, getConfig, runBuilder } from './utils';\nimport { setFailed } from '@actions/core';\nimport * as chalk from 'chalk';\nimport * as shell from 'shelljs';\nlet toBuild = 99;\nexport async function run() {\n    try {\n        log.info('Builder started');\n        const ws = getWorkspace();\n        const cfg = await getConfig();\n        if (cfg.dryRun) {\n            log.warn(chalk.yellow('[DRY_RUN] detected'));\n            cfg.lastOnly = true;\n        }\n        const token = getArg('token', { required: true });\n        const api = getOctokit(token);\n        addHostRule({ matchHost: 'github.com', token });\n        log('config:', JSON.stringify(cfg));\n        const builds = await getBuildList(cfg);\n        if (!builds?.versions.length) {\n            setFailed(`No versions found.`);\n            return;\n        }\n        shell.mkdir('-p', `${ws}/.cache`);\n        await init();\n        await createBuilderImage(ws, cfg);\n        const failed = [];\n        for (const version of builds.versions) {\n            await updateRelease(api, cfg, version);\n            if (await hasAsset(api, cfg, version)) {\n                if (!(await hasAsset(api, cfg, version, true))) {\n                    log('Creating checksum for existing version:', version);\n                    if (!(await downloadAsset(api, cfg, version))) {\n                        log.warn(chalk.yellow('Missing binary asset:'), version);\n                        failed.push(version);\n                        continue;\n                    }\n                    try {\n                        await createChecksum(cfg, version);\n                        if (cfg.dryRun) {\n                            log.warn(chalk.yellow('[DRY_RUN] Would upload release asset:'), version);\n                        }\n                        else {\n                            log('Uploading release:', version);\n                            await uploadAsset(api, cfg, version, true);\n                        }\n                    }\n                    catch (e) {\n                        failed.push(version);\n                        // eslint-disable-next-line\n                        log(`Version ${version} failed: ${e.message}`);\n                    }\n                    continue;\n                }\n                else if (cfg.dryRun) {\n                    log.warn(chalk.yellow('[DRY_RUN] Would skipp existing version:'), version);\n                }\n                else {\n                    log('Skipping existing version:', version);\n                    continue;\n                }\n            }\n            // istanbul ignore if\n            if (toBuild-- <= 0) {\n                log.info('Build limit reached');\n                break;\n            }\n            log.info('Processing version:', version);\n            try {\n                log('Runing builder:', version);\n                await runBuilder(ws, version);\n                await createChecksum(cfg, version);\n                if (cfg.dryRun) {\n                    log.warn(chalk.yellow('[DRY_RUN] Would upload release asset:'), version);\n                }\n                else {\n                    log('Uploading release:', version);\n                    await uploadAsset(api, cfg, version);\n                    await uploadAsset(api, cfg, version, true);\n                }\n            }\n            catch (e) {\n                failed.push(version);\n                // eslint-disable-next-line\n                log(`Version ${version} failed: ${e.message}`, e.stack);\n            }\n        }\n        if (failed.length) {\n            setFailed(`Versions failed: ${failed.join(', ')}`);\n        }\n    }\n    catch (error) {\n        log(error.stack);\n        setFailed(error);\n    }\n}\n","import * as fs from 'node:fs/promises';\nimport { join } from 'node:path';\nimport { ExecError } from './utils/types';\nimport { endGroup, getInput, startGroup } from '@actions/core';\nimport { exec as _exec } from '@actions/exec';\nimport { which } from '@actions/io';\nimport is from '@sindresorhus/is';\nimport * as findUp from 'find-up';\nconst DEFAULT_DISTRO = 'focal';\nexport async function exists(command) {\n    try {\n        await which(command, true);\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\nexport async function exec(cmd, args, options) {\n    let stdout = '';\n    let stderr = '';\n    let code;\n    try {\n        startGroup(`${cmd} ${args.join(' ')}`);\n        code = await _exec(cmd, args, {\n            ...options,\n            ignoreReturnCode: true,\n            listeners: {\n                stdout: (data) => {\n                    stdout += data.toString();\n                },\n                stderr: (data) => {\n                    stderr += data.toString();\n                },\n            },\n        });\n    }\n    finally {\n        endGroup();\n    }\n    if (code) {\n        throw new ExecError(code, stdout, stderr, `${cmd} ${args.join(' ')}`);\n    }\n    return { code, stdout, stderr };\n}\n/**\n * Get environment variable or empty string.\n * Used for easy mocking.\n * @param key variable name\n */\nexport function getEnv(key) {\n    return process.env[key] ?? '';\n}\nexport function isCI() {\n    return !!getEnv('CI');\n}\nexport function isDryRun() {\n    const val = getInput('dry-run') || getEnv('DRY_RUN');\n    return (!!val && val === 'true') || !isCI();\n}\nexport function getWorkspace() {\n    return getEnv('GITHUB_WORKSPACE') || process.cwd();\n}\nexport function getDistro() {\n    return getEnv('DISTRO') || getEnv('FLAVOR') || DEFAULT_DISTRO;\n}\nexport function getArch() {\n    return getEnv('ARCH');\n}\nexport async function readJson(file) {\n    const json = await readFile(file);\n    return JSON.parse(json);\n}\nexport async function readFile(file) {\n    const path = join(getWorkspace(), file);\n    return await fs.readFile(path, 'utf8');\n}\nexport async function readBuffer(file) {\n    const path = join(getWorkspace(), file);\n    return await fs.readFile(path);\n}\nexport async function writeFile(file, contents) {\n    const path = join(getWorkspace(), file);\n    await fs.writeFile(path, contents);\n}\nexport const MultiArgsSplitRe = /\\s*(?:[;,]|$)\\s*/;\nexport function getArg(name, opts) {\n    const val = getInput(name, opts);\n    return opts?.multi\n        ? val.split(MultiArgsSplitRe).filter(is.nonEmptyStringAndNotWhitespace)\n        : val;\n}\nlet _pkg;\n/**\n * Resolve path for a file relative to renovate root directory (our package.json)\n * @param file a file to resolve\n */\nexport async function resolveFile(file) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (!_pkg) {\n        _pkg = findUp('package.json', { cwd: __dirname, type: 'file' });\n    }\n    const pkg = await _pkg;\n    // istanbul ignore if\n    if (!pkg) {\n        throw new Error('Missing package.json');\n    }\n    return join(pkg, '../', file);\n}\n","import log from '../logger';\nimport { getDatasources } from 'renovate/dist/modules/datasource';\nexport function register() {\n    log('register datasources');\n    getDatasources();\n}\n","import { GenericVersioningApi, } from 'renovate/dist/modules/versioning/generic';\nimport { api as ubuntu } from 'renovate/dist/modules/versioning/ubuntu';\nconst versions = new Map([\n    ['bionic', { release: [18, 4] }],\n    ['focal', { release: [20, 4] }],\n]);\nexport const id = 'ubuntu';\nclass CustomUbuntuVersioning extends GenericVersioningApi {\n    _parse(version) {\n        let res = versions.get(version) ?? null;\n        if (!res && ubuntu.isValid(version)) {\n            res = { release: version.split('.').map((s) => parseInt(s, 10)) };\n        }\n        return res;\n    }\n    _compare(version1, version2) {\n        const parsed1 = this._parse(version1);\n        const parsed2 = this._parse(version2);\n        // istanbul ignore if\n        if (!parsed1 || !parsed2) {\n            return 1;\n        }\n        const length = Math.max(parsed1.release.length, parsed2.release.length);\n        for (let i = 0; i < length; i += 1) {\n            const part1 = parsed1.release[i];\n            const part2 = parsed2.release[i];\n            // shorter is bigger 2.1 > 2.1.1\n            // istanbul ignore if\n            if (part1 === undefined) {\n                return 1;\n            }\n            // istanbul ignore if\n            if (part2 === undefined) {\n                return -1;\n            }\n            if (part1 !== part2) {\n                return part1 - part2;\n            }\n        }\n        return 0;\n    }\n    isStable(version) {\n        return versions.has(version) || ubuntu.isStable(version);\n    }\n}\nexport const api = new CustomUbuntuVersioning();\nexport default api;\n","import log from '../logger';\nimport * as ubuntu from './ubuntu';\nimport { getVersionings } from 'renovate/dist/modules/versioning';\nexport function register() {\n    log('register versionings');\n    const ds = getVersionings();\n    ds.set(ubuntu.id, ubuntu.api);\n}\n","import * as renovate from './datasource';\nimport log from './logger';\nimport * as v from './versioning';\nexport function register() {\n    log('register renovate extensions');\n    renovate.register();\n    v.register();\n}\n","import log from './logger';\nimport * as renovate from './renovate';\nimport is from '@sindresorhus/is';\nimport { getPkgReleases, } from 'renovate/dist/modules/datasource';\nimport { get as getVersioning } from 'renovate/dist/modules/versioning';\nimport { add as addHostRule } from 'renovate/dist/util/host-rules';\nimport { configRegexPredicate } from 'renovate/dist/util/regex';\nimport * as semver from 'semver';\nrenovate.register();\nlet latestStable;\nexport { addHostRule };\nfunction getVersions(versions) {\n    return {\n        releases: versions.map((version) => ({\n            version,\n        })),\n    };\n}\nexport async function getBuildList({ allowedVersions, datasource, depName, lookupName, versioning, startVersion, ignoredVersions, lastOnly, forceUnstable, versions, latestVersion, maxVersions, extractVersion, }) {\n    log('Looking up versions');\n    const ver = getVersioning(versioning);\n    const pkgResult = versions\n        ? getVersions(versions)\n        : await getPkgReleases({\n            datasource,\n            packageName: lookupName ?? depName,\n            versioning,\n            extractVersion,\n        });\n    if (!pkgResult) {\n        return null;\n    }\n    let allVersions = pkgResult.releases\n        .map((v) => v.version)\n        .filter((v) => ver.isVersion(v) && ver.isCompatible(v, startVersion));\n    // filter duplicate versions (16.0.2+7 == 16.0.2+8)\n    allVersions = allVersions\n        .reverse()\n        .filter((v, i) => allVersions.findIndex((f) => ver.equals(f, v)) === i)\n        .reverse();\n    log(`Found ${allVersions.length} total versions`);\n    if (!allVersions.length) {\n        return null;\n    }\n    allVersions = allVersions\n        .filter((v) => v === startVersion || ver.isGreaterThan(v, startVersion))\n        .filter((v) => !ignoredVersions.includes(v));\n    if (!forceUnstable) {\n        log('Filter unstable versions');\n        allVersions = allVersions.filter((v) => ver.isStable(v));\n    }\n    if (is.string(allowedVersions)) {\n        const isAllowedPred = configRegexPredicate(allowedVersions);\n        if (isAllowedPred) {\n            allVersions = allVersions.filter((version) => isAllowedPred(version));\n        }\n        else if (ver.isValid(allowedVersions)) {\n            allVersions = allVersions.filter((version) => ver.matches(version, allowedVersions));\n        }\n        else if (semver.validRange(allowedVersions)) {\n            allVersions = allVersions.filter((v) => \n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            semver.satisfies(semver.coerce(v), allowedVersions));\n        }\n        else {\n            log.warn(`Invalid 'allowedVersions' options: ${allowedVersions}`);\n            return null;\n        }\n    }\n    if (!allVersions.length) {\n        log('Nothing to build');\n        return null;\n    }\n    log(`Found ${allVersions.length} versions within our range`);\n    log(`Candidates:`, allVersions.join(', '));\n    latestStable =\n        latestVersion ??\n            /* istanbul ignore next: not testable ts */\n            pkgResult.tags?.latest ??\n            allVersions.filter((v) => ver.isStable(v)).pop();\n    log('Latest stable version is', latestStable);\n    if (latestStable && !allVersions.includes(latestStable)) {\n        log.warn(`LatestStable '${latestStable}' not buildable, candidates:`, allVersions.join(', '));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastVersion = allVersions.at(-1);\n    log('Most recent version is', lastVersion);\n    if (is.number(maxVersions) && maxVersions > 0) {\n        log(`Building last ${maxVersions} version only`);\n        allVersions = allVersions.slice(-maxVersions);\n    }\n    if (lastOnly) {\n        log('Building last version only');\n        allVersions = [latestStable && !forceUnstable ? latestStable : lastVersion];\n    }\n    log('Build list:', allVersions.join(', '));\n    return { versions: allVersions, latestStable };\n}\n","import { getArch, getDistro, readFile } from '../util';\nimport { sumType } from './types';\nimport is from '@sindresorhus/is';\nimport * as escapeStringRegexp from 'escape-string-regexp';\nconst keys = [\n    'datasource',\n    'depName',\n    'lookupName',\n    'buildArg',\n    'versioning',\n    'latestVersion',\n];\nfunction checkArgs(cfg, groups) {\n    for (const key of keys) {\n        if (!is.string(cfg[key]) && is.nonEmptyString(groups[key])) {\n            cfg[key] = groups[key];\n        }\n    }\n}\nexport async function readDockerConfig(cfg) {\n    const buildArg = escapeStringRegexp(cfg.buildArg);\n    const dockerFileRe = new RegExp('# renovate: datasource=(?<datasource>[a-z-]+?) depName=(?<depName>.+?)(?: lookupName=(?<lookupName>.+?))?(?: versioning=(?<versioning>[a-z-]+?))?\\\\s' +\n        `(?:ENV|ARG) ${buildArg}=(?<latestVersion>.*)\\\\s`, 'g');\n    const dockerfile = await readFile('Dockerfile');\n    const m = dockerFileRe.exec(dockerfile);\n    if (m && m.groups) {\n        checkArgs(cfg, m.groups);\n    }\n}\nexport function getBinaryName(cfg, version, sum) {\n    const arch = getArch();\n    const ext = sum ? `.${sumType}` : '';\n    if (is.nonEmptyString(arch)) {\n        return `${cfg.image}-${version}-${getDistro()}-${arch}.tar.xz${ext}`;\n    }\n    return `${cfg.image}-${version}-${getDistro()}.tar.xz${ext}`;\n}\n","import log from '../logger';\nimport { docker, dockerBuildx, dockerRun } from './common';\nconst SupportedPlatforms = 'arm64';\nexport async function init(use) {\n    const buildx = await dockerBuildx('ls');\n    if (buildx.stdout.includes('renovatebot-builder')) {\n        log('Buildx already initialized');\n        process.env.BUILDX_BUILDER = 'renovatebot-builder';\n        return;\n    }\n    log.info('Configure buildx');\n    await docker('info');\n    // install emulations\n    // https://github.com/docker/setup-qemu-action/blob/9d419fda7df46b2bcd38fadda3ec44f4748d25e1/src/main.ts#L22\n    await dockerRun('--privileged', 'tonistiigi/binfmt', '--install', SupportedPlatforms);\n    await dockerBuildx('version');\n    await dockerBuildx('create', '--name', 'renovatebot-builder', '--driver', 'docker-container');\n    // istanbul ignore if\n    if (use) {\n        await dockerBuildx('use', 'renovatebot-builder');\n    }\n    await dockerBuildx('inspect', '--bootstrap', 'renovatebot-builder');\n    process.env.BUILDX_BUILDER = 'renovatebot-builder';\n    await dockerBuildx('ls');\n}\n","import { exec } from '../../util';\nimport log from '../logger';\nexport var DockerPlatform;\n(function (DockerPlatform) {\n    DockerPlatform[\"x86_64\"] = \"linux/amd64\";\n    DockerPlatform[\"aarch64\"] = \"linux/arm64\";\n})(DockerPlatform || (DockerPlatform = {}));\nexport async function docker(...args) {\n    return await exec('docker', [...args]);\n}\nexport async function dockerRun(...args) {\n    await docker('run', '--rm', ...args);\n}\nexport async function dockerBuildx(...args) {\n    return await docker('buildx', ...args);\n}\nexport async function dockerPrune() {\n    log('Pruning docker system');\n    await docker('system', 'prune', '--force', '--all');\n}\nexport async function dockerDf() {\n    log('Docker system disk usage');\n    await docker('system', 'df');\n}\n","export class ExecError extends Error {\n    code;\n    stdout;\n    stderr;\n    cmd;\n    name = 'ExecError';\n    constructor(code, stdout, stderr, cmd) {\n        super(`ExecError: (${code}) ` + stderr.split('\\n').slice(-10).join('\\n'));\n        this.code = code;\n        this.stdout = stdout;\n        this.stderr = stderr;\n        this.cmd = cmd;\n    }\n}\nexport const sumType = 'sha512';\n"],"names":[],"sourceRoot":""}