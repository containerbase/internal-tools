{"version":3,"file":"855.index.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./commands/docker/config.ts","webpack:///./util.ts","webpack:///./utils/docker/buildx.ts","webpack:///./utils/docker/common.ts","webpack:///./utils/types.ts"],"sourcesContent":["import { init } from '../../utils/docker/buildx';\nexport async function run() {\n    await init(true);\n}\n","import * as fs from 'node:fs/promises';\nimport { join } from 'node:path';\nimport { ExecError } from './utils/types';\nimport { endGroup, getInput, startGroup } from '@actions/core';\nimport { exec as _exec } from '@actions/exec';\nimport { which } from '@actions/io';\nimport * as findUp from 'find-up';\nconst DEFAULT_DISTRO = 'focal';\nexport async function exists(command) {\n    try {\n        await which(command, true);\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\nexport async function exec(cmd, args, options) {\n    let stdout = '';\n    let stderr = '';\n    let code;\n    try {\n        startGroup(`${cmd} ${args.join(' ')}`);\n        code = await _exec(cmd, args, {\n            ...options,\n            ignoreReturnCode: true,\n            listeners: {\n                stdout: (data) => {\n                    stdout += data.toString();\n                },\n                stderr: (data) => {\n                    stderr += data.toString();\n                },\n            },\n        });\n    }\n    finally {\n        endGroup();\n    }\n    if (code) {\n        throw new ExecError(code, stdout, stderr, `${cmd} ${args.join(' ')}`);\n    }\n    return { code, stdout, stderr };\n}\n/**\n * Get environment variable or empty string.\n * Used for easy mocking.\n * @param key variable name\n */\nexport function getEnv(key) {\n    return process.env[key] ?? '';\n}\nexport function isCI() {\n    return !!getEnv('CI');\n}\nexport function isDryRun() {\n    const val = getInput('dry-run') || getEnv('DRY_RUN');\n    return (!!val && val === 'true') || !isCI();\n}\nexport function getWorkspace() {\n    return getEnv('GITHUB_WORKSPACE') || process.cwd();\n}\nexport function getDistro() {\n    return getEnv('DISTRO') || getEnv('FLAVOR') || DEFAULT_DISTRO;\n}\nexport function getArch() {\n    return getEnv('ARCH');\n}\nexport async function readJson(file) {\n    const json = await readFile(file);\n    return JSON.parse(json);\n}\nexport async function readFile(file) {\n    const path = join(getWorkspace(), file);\n    return await fs.readFile(path, 'utf8');\n}\nexport async function readBuffer(file) {\n    const path = join(getWorkspace(), file);\n    return await fs.readFile(path);\n}\nexport async function writeFile(file, contents) {\n    const path = join(getWorkspace(), file);\n    await fs.writeFile(path, contents);\n}\nexport const MultiArgsSplitRe = /\\s*(?:[;,]|$)\\s*/;\nexport function getArg(name, opts) {\n    const val = getInput(name, opts);\n    return opts?.multi ? val.split(MultiArgsSplitRe).filter(Boolean) : val;\n}\nlet _pkg;\n/**\n * Resolve path for a file relative to renovate root directory (our package.json)\n * @param file a file to resolve\n */\nexport async function resolveFile(file) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (!_pkg) {\n        _pkg = findUp('package.json', { cwd: __dirname, type: 'file' });\n    }\n    const pkg = await _pkg;\n    // istanbul ignore if\n    if (!pkg) {\n        throw new Error('Missing package.json');\n    }\n    return join(pkg, '../', file);\n}\n/**\n * Stop processing for some time.\n * @param milliseconds time to sleep\n */\nexport function sleep(milliseconds) {\n    return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n","import log from '../logger';\nimport { docker, dockerBuildx, dockerRun } from './common';\nconst SupportedPlatforms = 'arm64';\nexport async function init(use) {\n    const buildx = await dockerBuildx('ls');\n    if (buildx.stdout.includes('renovatebot-builder')) {\n        log('Buildx already initialized');\n        process.env.BUILDX_BUILDER = 'renovatebot-builder';\n        return;\n    }\n    log.info('Configure buildx');\n    await docker('info');\n    // install emulations\n    // https://github.com/docker/setup-qemu-action/blob/9d419fda7df46b2bcd38fadda3ec44f4748d25e1/src/main.ts#L22\n    await dockerRun('--privileged', 'tonistiigi/binfmt', '--install', SupportedPlatforms);\n    await dockerBuildx('version');\n    await dockerBuildx('create', '--name', 'renovatebot-builder', '--driver', 'docker-container');\n    // istanbul ignore if\n    if (use) {\n        await dockerBuildx('use', 'renovatebot-builder');\n    }\n    await dockerBuildx('inspect', '--bootstrap', 'renovatebot-builder');\n    process.env.BUILDX_BUILDER = 'renovatebot-builder';\n    await dockerBuildx('ls');\n}\n","import { exec } from '../../util';\nimport log from '../logger';\nexport var DockerPlatform;\n(function (DockerPlatform) {\n    DockerPlatform[\"x86_64\"] = \"linux/amd64\";\n    DockerPlatform[\"aarch64\"] = \"linux/arm64\";\n})(DockerPlatform || (DockerPlatform = {}));\nexport async function docker(...args) {\n    return await exec('docker', [...args]);\n}\nexport async function dockerRun(...args) {\n    await docker('run', '--rm', ...args);\n}\nexport async function dockerBuildx(...args) {\n    return await docker('buildx', ...args);\n}\nexport async function dockerPrune() {\n    log('Pruning docker system');\n    await docker('system', 'prune', '--force', '--all');\n}\nexport async function dockerDf() {\n    log('Docker system disk usage');\n    await docker('system', 'df');\n}\n","export class ExecError extends Error {\n    code;\n    stdout;\n    stderr;\n    cmd;\n    name = 'ExecError';\n    constructor(code, stdout, stderr, cmd) {\n        super(`ExecError: (${code}) ` + stderr.split('\\n').slice(-10).join('\\n'));\n        this.code = code;\n        this.stdout = stdout;\n        this.stderr = stderr;\n        this.cmd = cmd;\n    }\n}\nexport const sumType = 'sha512';\n"],"names":[],"sourceRoot":""}